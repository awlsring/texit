// Code generated by mockery v2.40.1. DO NOT EDIT.

package mocks

import (
	context "context"

	ecs "github.com/aws/aws-sdk-go-v2/service/ecs"

	mock "github.com/stretchr/testify/mock"
)

// MockEcsClient_interfaces is an autogenerated mock type for the EcsClient type
type MockEcsClient_interfaces struct {
	mock.Mock
}

type MockEcsClient_interfaces_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEcsClient_interfaces) EXPECT() *MockEcsClient_interfaces_Expecter {
	return &MockEcsClient_interfaces_Expecter{mock: &_m.Mock}
}

// CreateCluster provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) CreateCluster(ctx context.Context, params *ecs.CreateClusterInput, optFns ...func(*ecs.Options)) (*ecs.CreateClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCluster")
	}

	var r0 *ecs.CreateClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.CreateClusterInput, ...func(*ecs.Options)) (*ecs.CreateClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.CreateClusterInput, ...func(*ecs.Options)) *ecs.CreateClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.CreateClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.CreateClusterInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_CreateCluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCluster'
type MockEcsClient_interfaces_CreateCluster_Call struct {
	*mock.Call
}

// CreateCluster is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.CreateClusterInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) CreateCluster(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_CreateCluster_Call {
	return &MockEcsClient_interfaces_CreateCluster_Call{Call: _e.mock.On("CreateCluster",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_CreateCluster_Call) Run(run func(ctx context.Context, params *ecs.CreateClusterInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_CreateCluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.CreateClusterInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_CreateCluster_Call) Return(_a0 *ecs.CreateClusterOutput, _a1 error) *MockEcsClient_interfaces_CreateCluster_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_CreateCluster_Call) RunAndReturn(run func(context.Context, *ecs.CreateClusterInput, ...func(*ecs.Options)) (*ecs.CreateClusterOutput, error)) *MockEcsClient_interfaces_CreateCluster_Call {
	_c.Call.Return(run)
	return _c
}

// CreateService provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) CreateService(ctx context.Context, params *ecs.CreateServiceInput, optFns ...func(*ecs.Options)) (*ecs.CreateServiceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateService")
	}

	var r0 *ecs.CreateServiceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.CreateServiceInput, ...func(*ecs.Options)) (*ecs.CreateServiceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.CreateServiceInput, ...func(*ecs.Options)) *ecs.CreateServiceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.CreateServiceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.CreateServiceInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_CreateService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateService'
type MockEcsClient_interfaces_CreateService_Call struct {
	*mock.Call
}

// CreateService is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.CreateServiceInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) CreateService(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_CreateService_Call {
	return &MockEcsClient_interfaces_CreateService_Call{Call: _e.mock.On("CreateService",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_CreateService_Call) Run(run func(ctx context.Context, params *ecs.CreateServiceInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_CreateService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.CreateServiceInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_CreateService_Call) Return(_a0 *ecs.CreateServiceOutput, _a1 error) *MockEcsClient_interfaces_CreateService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_CreateService_Call) RunAndReturn(run func(context.Context, *ecs.CreateServiceInput, ...func(*ecs.Options)) (*ecs.CreateServiceOutput, error)) *MockEcsClient_interfaces_CreateService_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTaskSet provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) CreateTaskSet(ctx context.Context, params *ecs.CreateTaskSetInput, optFns ...func(*ecs.Options)) (*ecs.CreateTaskSetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTaskSet")
	}

	var r0 *ecs.CreateTaskSetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.CreateTaskSetInput, ...func(*ecs.Options)) (*ecs.CreateTaskSetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.CreateTaskSetInput, ...func(*ecs.Options)) *ecs.CreateTaskSetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.CreateTaskSetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.CreateTaskSetInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_CreateTaskSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTaskSet'
type MockEcsClient_interfaces_CreateTaskSet_Call struct {
	*mock.Call
}

// CreateTaskSet is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.CreateTaskSetInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) CreateTaskSet(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_CreateTaskSet_Call {
	return &MockEcsClient_interfaces_CreateTaskSet_Call{Call: _e.mock.On("CreateTaskSet",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_CreateTaskSet_Call) Run(run func(ctx context.Context, params *ecs.CreateTaskSetInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_CreateTaskSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.CreateTaskSetInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_CreateTaskSet_Call) Return(_a0 *ecs.CreateTaskSetOutput, _a1 error) *MockEcsClient_interfaces_CreateTaskSet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_CreateTaskSet_Call) RunAndReturn(run func(context.Context, *ecs.CreateTaskSetInput, ...func(*ecs.Options)) (*ecs.CreateTaskSetOutput, error)) *MockEcsClient_interfaces_CreateTaskSet_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteService provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) DeleteService(ctx context.Context, params *ecs.DeleteServiceInput, optFns ...func(*ecs.Options)) (*ecs.DeleteServiceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteService")
	}

	var r0 *ecs.DeleteServiceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DeleteServiceInput, ...func(*ecs.Options)) (*ecs.DeleteServiceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DeleteServiceInput, ...func(*ecs.Options)) *ecs.DeleteServiceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.DeleteServiceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.DeleteServiceInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_DeleteService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteService'
type MockEcsClient_interfaces_DeleteService_Call struct {
	*mock.Call
}

// DeleteService is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.DeleteServiceInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) DeleteService(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_DeleteService_Call {
	return &MockEcsClient_interfaces_DeleteService_Call{Call: _e.mock.On("DeleteService",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_DeleteService_Call) Run(run func(ctx context.Context, params *ecs.DeleteServiceInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_DeleteService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.DeleteServiceInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_DeleteService_Call) Return(_a0 *ecs.DeleteServiceOutput, _a1 error) *MockEcsClient_interfaces_DeleteService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_DeleteService_Call) RunAndReturn(run func(context.Context, *ecs.DeleteServiceInput, ...func(*ecs.Options)) (*ecs.DeleteServiceOutput, error)) *MockEcsClient_interfaces_DeleteService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTaskDefinitions provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) DeleteTaskDefinitions(ctx context.Context, params *ecs.DeleteTaskDefinitionsInput, optFns ...func(*ecs.Options)) (*ecs.DeleteTaskDefinitionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTaskDefinitions")
	}

	var r0 *ecs.DeleteTaskDefinitionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DeleteTaskDefinitionsInput, ...func(*ecs.Options)) (*ecs.DeleteTaskDefinitionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DeleteTaskDefinitionsInput, ...func(*ecs.Options)) *ecs.DeleteTaskDefinitionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.DeleteTaskDefinitionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.DeleteTaskDefinitionsInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_DeleteTaskDefinitions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTaskDefinitions'
type MockEcsClient_interfaces_DeleteTaskDefinitions_Call struct {
	*mock.Call
}

// DeleteTaskDefinitions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.DeleteTaskDefinitionsInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) DeleteTaskDefinitions(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_DeleteTaskDefinitions_Call {
	return &MockEcsClient_interfaces_DeleteTaskDefinitions_Call{Call: _e.mock.On("DeleteTaskDefinitions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_DeleteTaskDefinitions_Call) Run(run func(ctx context.Context, params *ecs.DeleteTaskDefinitionsInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_DeleteTaskDefinitions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.DeleteTaskDefinitionsInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_DeleteTaskDefinitions_Call) Return(_a0 *ecs.DeleteTaskDefinitionsOutput, _a1 error) *MockEcsClient_interfaces_DeleteTaskDefinitions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_DeleteTaskDefinitions_Call) RunAndReturn(run func(context.Context, *ecs.DeleteTaskDefinitionsInput, ...func(*ecs.Options)) (*ecs.DeleteTaskDefinitionsOutput, error)) *MockEcsClient_interfaces_DeleteTaskDefinitions_Call {
	_c.Call.Return(run)
	return _c
}

// DeregisterTaskDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) DeregisterTaskDefinition(ctx context.Context, params *ecs.DeregisterTaskDefinitionInput, optFns ...func(*ecs.Options)) (*ecs.DeregisterTaskDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterTaskDefinition")
	}

	var r0 *ecs.DeregisterTaskDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DeregisterTaskDefinitionInput, ...func(*ecs.Options)) (*ecs.DeregisterTaskDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DeregisterTaskDefinitionInput, ...func(*ecs.Options)) *ecs.DeregisterTaskDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.DeregisterTaskDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.DeregisterTaskDefinitionInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_DeregisterTaskDefinition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeregisterTaskDefinition'
type MockEcsClient_interfaces_DeregisterTaskDefinition_Call struct {
	*mock.Call
}

// DeregisterTaskDefinition is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.DeregisterTaskDefinitionInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) DeregisterTaskDefinition(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_DeregisterTaskDefinition_Call {
	return &MockEcsClient_interfaces_DeregisterTaskDefinition_Call{Call: _e.mock.On("DeregisterTaskDefinition",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_DeregisterTaskDefinition_Call) Run(run func(ctx context.Context, params *ecs.DeregisterTaskDefinitionInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_DeregisterTaskDefinition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.DeregisterTaskDefinitionInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_DeregisterTaskDefinition_Call) Return(_a0 *ecs.DeregisterTaskDefinitionOutput, _a1 error) *MockEcsClient_interfaces_DeregisterTaskDefinition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_DeregisterTaskDefinition_Call) RunAndReturn(run func(context.Context, *ecs.DeregisterTaskDefinitionInput, ...func(*ecs.Options)) (*ecs.DeregisterTaskDefinitionOutput, error)) *MockEcsClient_interfaces_DeregisterTaskDefinition_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeClusters provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) DescribeClusters(ctx context.Context, params *ecs.DescribeClustersInput, optFns ...func(*ecs.Options)) (*ecs.DescribeClustersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClusters")
	}

	var r0 *ecs.DescribeClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DescribeClustersInput, ...func(*ecs.Options)) (*ecs.DescribeClustersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DescribeClustersInput, ...func(*ecs.Options)) *ecs.DescribeClustersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.DescribeClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.DescribeClustersInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_DescribeClusters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeClusters'
type MockEcsClient_interfaces_DescribeClusters_Call struct {
	*mock.Call
}

// DescribeClusters is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.DescribeClustersInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) DescribeClusters(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_DescribeClusters_Call {
	return &MockEcsClient_interfaces_DescribeClusters_Call{Call: _e.mock.On("DescribeClusters",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_DescribeClusters_Call) Run(run func(ctx context.Context, params *ecs.DescribeClustersInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_DescribeClusters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.DescribeClustersInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_DescribeClusters_Call) Return(_a0 *ecs.DescribeClustersOutput, _a1 error) *MockEcsClient_interfaces_DescribeClusters_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_DescribeClusters_Call) RunAndReturn(run func(context.Context, *ecs.DescribeClustersInput, ...func(*ecs.Options)) (*ecs.DescribeClustersOutput, error)) *MockEcsClient_interfaces_DescribeClusters_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeServices provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) DescribeServices(ctx context.Context, params *ecs.DescribeServicesInput, optFns ...func(*ecs.Options)) (*ecs.DescribeServicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeServices")
	}

	var r0 *ecs.DescribeServicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DescribeServicesInput, ...func(*ecs.Options)) (*ecs.DescribeServicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DescribeServicesInput, ...func(*ecs.Options)) *ecs.DescribeServicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.DescribeServicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.DescribeServicesInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_DescribeServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeServices'
type MockEcsClient_interfaces_DescribeServices_Call struct {
	*mock.Call
}

// DescribeServices is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.DescribeServicesInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) DescribeServices(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_DescribeServices_Call {
	return &MockEcsClient_interfaces_DescribeServices_Call{Call: _e.mock.On("DescribeServices",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_DescribeServices_Call) Run(run func(ctx context.Context, params *ecs.DescribeServicesInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_DescribeServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.DescribeServicesInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_DescribeServices_Call) Return(_a0 *ecs.DescribeServicesOutput, _a1 error) *MockEcsClient_interfaces_DescribeServices_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_DescribeServices_Call) RunAndReturn(run func(context.Context, *ecs.DescribeServicesInput, ...func(*ecs.Options)) (*ecs.DescribeServicesOutput, error)) *MockEcsClient_interfaces_DescribeServices_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTasks provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) DescribeTasks(ctx context.Context, params *ecs.DescribeTasksInput, optFns ...func(*ecs.Options)) (*ecs.DescribeTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTasks")
	}

	var r0 *ecs.DescribeTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DescribeTasksInput, ...func(*ecs.Options)) (*ecs.DescribeTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.DescribeTasksInput, ...func(*ecs.Options)) *ecs.DescribeTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.DescribeTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.DescribeTasksInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_DescribeTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTasks'
type MockEcsClient_interfaces_DescribeTasks_Call struct {
	*mock.Call
}

// DescribeTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.DescribeTasksInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) DescribeTasks(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_DescribeTasks_Call {
	return &MockEcsClient_interfaces_DescribeTasks_Call{Call: _e.mock.On("DescribeTasks",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_DescribeTasks_Call) Run(run func(ctx context.Context, params *ecs.DescribeTasksInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_DescribeTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.DescribeTasksInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_DescribeTasks_Call) Return(_a0 *ecs.DescribeTasksOutput, _a1 error) *MockEcsClient_interfaces_DescribeTasks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_DescribeTasks_Call) RunAndReturn(run func(context.Context, *ecs.DescribeTasksInput, ...func(*ecs.Options)) (*ecs.DescribeTasksOutput, error)) *MockEcsClient_interfaces_DescribeTasks_Call {
	_c.Call.Return(run)
	return _c
}

// ListClusters provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) ListClusters(ctx context.Context, params *ecs.ListClustersInput, optFns ...func(*ecs.Options)) (*ecs.ListClustersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListClusters")
	}

	var r0 *ecs.ListClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.ListClustersInput, ...func(*ecs.Options)) (*ecs.ListClustersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.ListClustersInput, ...func(*ecs.Options)) *ecs.ListClustersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.ListClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.ListClustersInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_ListClusters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListClusters'
type MockEcsClient_interfaces_ListClusters_Call struct {
	*mock.Call
}

// ListClusters is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.ListClustersInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) ListClusters(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_ListClusters_Call {
	return &MockEcsClient_interfaces_ListClusters_Call{Call: _e.mock.On("ListClusters",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_ListClusters_Call) Run(run func(ctx context.Context, params *ecs.ListClustersInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_ListClusters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.ListClustersInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_ListClusters_Call) Return(_a0 *ecs.ListClustersOutput, _a1 error) *MockEcsClient_interfaces_ListClusters_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_ListClusters_Call) RunAndReturn(run func(context.Context, *ecs.ListClustersInput, ...func(*ecs.Options)) (*ecs.ListClustersOutput, error)) *MockEcsClient_interfaces_ListClusters_Call {
	_c.Call.Return(run)
	return _c
}

// ListTasks provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) ListTasks(ctx context.Context, params *ecs.ListTasksInput, optFns ...func(*ecs.Options)) (*ecs.ListTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTasks")
	}

	var r0 *ecs.ListTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.ListTasksInput, ...func(*ecs.Options)) (*ecs.ListTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.ListTasksInput, ...func(*ecs.Options)) *ecs.ListTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.ListTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.ListTasksInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_ListTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTasks'
type MockEcsClient_interfaces_ListTasks_Call struct {
	*mock.Call
}

// ListTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.ListTasksInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) ListTasks(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_ListTasks_Call {
	return &MockEcsClient_interfaces_ListTasks_Call{Call: _e.mock.On("ListTasks",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_ListTasks_Call) Run(run func(ctx context.Context, params *ecs.ListTasksInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_ListTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.ListTasksInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_ListTasks_Call) Return(_a0 *ecs.ListTasksOutput, _a1 error) *MockEcsClient_interfaces_ListTasks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_ListTasks_Call) RunAndReturn(run func(context.Context, *ecs.ListTasksInput, ...func(*ecs.Options)) (*ecs.ListTasksOutput, error)) *MockEcsClient_interfaces_ListTasks_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterTaskDefinition provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) RegisterTaskDefinition(ctx context.Context, params *ecs.RegisterTaskDefinitionInput, optFns ...func(*ecs.Options)) (*ecs.RegisterTaskDefinitionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterTaskDefinition")
	}

	var r0 *ecs.RegisterTaskDefinitionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.RegisterTaskDefinitionInput, ...func(*ecs.Options)) (*ecs.RegisterTaskDefinitionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.RegisterTaskDefinitionInput, ...func(*ecs.Options)) *ecs.RegisterTaskDefinitionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.RegisterTaskDefinitionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.RegisterTaskDefinitionInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_RegisterTaskDefinition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterTaskDefinition'
type MockEcsClient_interfaces_RegisterTaskDefinition_Call struct {
	*mock.Call
}

// RegisterTaskDefinition is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.RegisterTaskDefinitionInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) RegisterTaskDefinition(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_RegisterTaskDefinition_Call {
	return &MockEcsClient_interfaces_RegisterTaskDefinition_Call{Call: _e.mock.On("RegisterTaskDefinition",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_RegisterTaskDefinition_Call) Run(run func(ctx context.Context, params *ecs.RegisterTaskDefinitionInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_RegisterTaskDefinition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.RegisterTaskDefinitionInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_RegisterTaskDefinition_Call) Return(_a0 *ecs.RegisterTaskDefinitionOutput, _a1 error) *MockEcsClient_interfaces_RegisterTaskDefinition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_RegisterTaskDefinition_Call) RunAndReturn(run func(context.Context, *ecs.RegisterTaskDefinitionInput, ...func(*ecs.Options)) (*ecs.RegisterTaskDefinitionOutput, error)) *MockEcsClient_interfaces_RegisterTaskDefinition_Call {
	_c.Call.Return(run)
	return _c
}

// RunTask provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) RunTask(ctx context.Context, params *ecs.RunTaskInput, optFns ...func(*ecs.Options)) (*ecs.RunTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RunTask")
	}

	var r0 *ecs.RunTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.RunTaskInput, ...func(*ecs.Options)) (*ecs.RunTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.RunTaskInput, ...func(*ecs.Options)) *ecs.RunTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.RunTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.RunTaskInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_RunTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunTask'
type MockEcsClient_interfaces_RunTask_Call struct {
	*mock.Call
}

// RunTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.RunTaskInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) RunTask(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_RunTask_Call {
	return &MockEcsClient_interfaces_RunTask_Call{Call: _e.mock.On("RunTask",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_RunTask_Call) Run(run func(ctx context.Context, params *ecs.RunTaskInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_RunTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.RunTaskInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_RunTask_Call) Return(_a0 *ecs.RunTaskOutput, _a1 error) *MockEcsClient_interfaces_RunTask_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_RunTask_Call) RunAndReturn(run func(context.Context, *ecs.RunTaskInput, ...func(*ecs.Options)) (*ecs.RunTaskOutput, error)) *MockEcsClient_interfaces_RunTask_Call {
	_c.Call.Return(run)
	return _c
}

// StopTask provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) StopTask(ctx context.Context, params *ecs.StopTaskInput, optFns ...func(*ecs.Options)) (*ecs.StopTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopTask")
	}

	var r0 *ecs.StopTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.StopTaskInput, ...func(*ecs.Options)) (*ecs.StopTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.StopTaskInput, ...func(*ecs.Options)) *ecs.StopTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.StopTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.StopTaskInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_StopTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopTask'
type MockEcsClient_interfaces_StopTask_Call struct {
	*mock.Call
}

// StopTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.StopTaskInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) StopTask(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_StopTask_Call {
	return &MockEcsClient_interfaces_StopTask_Call{Call: _e.mock.On("StopTask",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_StopTask_Call) Run(run func(ctx context.Context, params *ecs.StopTaskInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_StopTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.StopTaskInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_StopTask_Call) Return(_a0 *ecs.StopTaskOutput, _a1 error) *MockEcsClient_interfaces_StopTask_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_StopTask_Call) RunAndReturn(run func(context.Context, *ecs.StopTaskInput, ...func(*ecs.Options)) (*ecs.StopTaskOutput, error)) *MockEcsClient_interfaces_StopTask_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateService provides a mock function with given fields: ctx, params, optFns
func (_m *MockEcsClient_interfaces) UpdateService(ctx context.Context, params *ecs.UpdateServiceInput, optFns ...func(*ecs.Options)) (*ecs.UpdateServiceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateService")
	}

	var r0 *ecs.UpdateServiceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.UpdateServiceInput, ...func(*ecs.Options)) (*ecs.UpdateServiceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ecs.UpdateServiceInput, ...func(*ecs.Options)) *ecs.UpdateServiceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ecs.UpdateServiceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ecs.UpdateServiceInput, ...func(*ecs.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockEcsClient_interfaces_UpdateService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateService'
type MockEcsClient_interfaces_UpdateService_Call struct {
	*mock.Call
}

// UpdateService is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ecs.UpdateServiceInput
//   - optFns ...func(*ecs.Options)
func (_e *MockEcsClient_interfaces_Expecter) UpdateService(ctx interface{}, params interface{}, optFns ...interface{}) *MockEcsClient_interfaces_UpdateService_Call {
	return &MockEcsClient_interfaces_UpdateService_Call{Call: _e.mock.On("UpdateService",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEcsClient_interfaces_UpdateService_Call) Run(run func(ctx context.Context, params *ecs.UpdateServiceInput, optFns ...func(*ecs.Options))) *MockEcsClient_interfaces_UpdateService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ecs.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ecs.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ecs.UpdateServiceInput), variadicArgs...)
	})
	return _c
}

func (_c *MockEcsClient_interfaces_UpdateService_Call) Return(_a0 *ecs.UpdateServiceOutput, _a1 error) *MockEcsClient_interfaces_UpdateService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockEcsClient_interfaces_UpdateService_Call) RunAndReturn(run func(context.Context, *ecs.UpdateServiceInput, ...func(*ecs.Options)) (*ecs.UpdateServiceOutput, error)) *MockEcsClient_interfaces_UpdateService_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEcsClient_interfaces creates a new instance of MockEcsClient_interfaces. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEcsClient_interfaces(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEcsClient_interfaces {
	mock := &MockEcsClient_interfaces{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
